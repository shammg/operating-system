## Homework 3 - Semaphores and Operating System Simulator
##### DESCRIPTION:
In this project you will be creating an empty shell of an os simulator and 
doing some very basic tasks in preparation for a more comprehensive simulation later. This will require the use of fork, exec, shared memory, and semaphores.

**NOTE:**
- Generate Key using ftok()
- Use relative path to avoid error
- Logical clock could be critical error

```
=====Operating System Simulator=====
- This will be your main program and serve as the master process. 
- You will start the operating system simulator (call the executable OSS) as one main process 
	which will start by forking a number of processes and will then fork new children as
	some terminate. 
- You want to make sure that your never exceed a specified number of processes in your system 
	which is why you fork new processes as existing ones terminate.

	1. As we will make a simulator, we will need to maintain our own system clock. 
	
	2. OSS will start by first allocating shared memory for a clock that gets incremented only by itself. 
	
	3. The child processes should be able to view this memory but will not increment it. 
	
	4. This shared memory clock should be two integers, with one integer to hold seconds and the other integer
		to hold nanoseconds. 
		a. So if one integer has 5 and the other has 10000 then that would mean that the clock is showing 5
			seconds and 10000 nanoseconds. 
		b. This clock should initially be set to 0.
		
	5. In addition to this shared memory clock, there should be an additional area of shared memory allocated to 
		allow the child processes to send information to the parent (OSS). Let us call this area shmMsg.


	6. With the clock at zero, OSS should fork the appropriate number of child processes to start. 
		Then it should enter into a loop. 
		
	7. During each iteration of that loop, it should increment the clock (simulating time passing in our system). 
	
	8. While in this loop, OSS should be checking shmMsg. 
	
		a. If it has been sent a message from the child, it should output the contents of that message 
			(which should be a set of two integers, a value in our clock) to a file. 
		b. If there is a message in shmMsg, that means that the child process is terminating, 
			so OSS should then do a wait until that process has left the system and then fork off
			another child and clear shmMsg. 
		c. This process should continue until 2 seconds have passed in the simulated system time, or
			a total of 100 child processes have been generated, or the executable has been running for the 
			maximum time allotted (in real seconds). 
		d. At that point, OSS should terminate all children and then itself, while making sure to clean up any shared
		memory and semaphores it is using.
	
	
- NOTE: that I did not specify how much OSS should increment the clock in each iteration. This will depend on your implementation.
	Tune it so that your system has some turnover.

The log file should at least have the following information, but can contain additional information:
Master: Child pid is terminating at my time xx.yy because it reached mm.nn in child process
Master: Child pid is terminating at my time xx.yy because it reached mm.nn in child process
Master: Child pid is terminating at my time xx.yy because it reached mm.nn in child process
...
with xx.yy being the time in the simulated system clock when OSS received the message and mm.nn is the time
	that the USER process put in shmMsg.
```

```
=====USER Processes=====
- The child processes of the OSS are the USER processes. 
- These should be a separate executable from OSS, run with a version of exec system call from the fork of OSS.

	1. This process should start by reading the simulated time system clock generated by OSS. 
	
	2. It should then generate a random duration number of simulated nanoseconds from 1 to 1000000 and 
		add this to the time it got from reading our shared memory clock. 
		a. This represents the time in our system when this process should terminate itself.
		
	3. It should then loop continually over a critical section of code. This critical section should be enforced 
		through the use of semaphores.
		
	4. Each iteration over the critical section, the USER processes should examine the OSS-managed clock and see if its maximum
		duration has passed. 
	
	5. If while in the critical section it sees that its duration is up and there is nothing already in shmMsg,
		it should send a message to OSS that it is going to terminate. 

	6. Once it has put a message in shmMsg it should terminate itself, making sure to cede the critical section to any other USER 
		processes before doing so. 
	
	7. If shmMsg is not empty, the USER process should cede the critical section and then when it next enters the critical section 
		it should then try and terminate.
	
	8. This checking of duration vs OSS clock and putting a message in the shmMsg for master should only occur in the critical
		section.
	
	9. If a USER process gets inside the critical section and sees that its duration has not passed, it should cede the critical
		section to another process and immediately attempt to get back in the critical section.


- NOTE: Make sure that you have signal handing to terminate all processes, if needed. In case of abnormal termination, make
	sure to remove any resources that are used. In particular, freeing up shared memory and our semaphore.

Your main executable should use command line arguments. You must implement at least the following command line
arguments using getopt:
	-h
	-s x
	-l filename
	-t z

	1. Where x is the maximum number of child processes spawned (default 5) and 
	2. Filename is the log file used. 
	3. The parameter z is the time in real (not simulated) seconds when the master will terminate itself and all children (default 5).
```

```
=====Implementation=====
The code for OSS and USER processes should be compiled separately and the executables be called OSS and USER. The
program should be executed by

	./oss
```

```
=====Hints=====
I highly suggest you do this project incrementally.
	- Test out the command line options, then spawn the child processes but just have them all immediately terminate.
	- Encode the shared memory and termination after a specified time. Check to make sure the child processes can access
		and modify the shared memory clock and message.
	- Insert semaphores and enforcement of critical region.
	- Test communication between USER and OS
	- Try and get OSS to spawn new children as others terminate.

If you do one task at a time it ensures that you know where the problem is if one crops up.
```

--------------------------------------------------------------------------------
##### HOW TO RUN:
1. In your command promt, type: make
2. This will generate .o file and executable file
3. To use the program, type: ./oss
4. You will be creating an empty shell of an os simulator and doing some very basic tasks
	in preparation for a more comprehensive simulation later. 
5. For more option with this program, type: ./oss -h
6. Few examples:
	- ./oss -h : print out the help page and exit.
	- ./oss -s : specifies the maximum number of child processes spawned (default 5)
	- ./oss -l : specifies the log file (default is log.dat)
	- ./oss -t : specifies the time in real (not simulated) seconds when the master will terminate itself and all children (default 5)
> !!!IMPORTANT NOTE FOR LOG FILE!!!	
> - The log file will have a large file size because all the procedure (where OSS and USER entering critical section) will be recorded. This is for debugging purpose (for developer) and for the other to see what is going in this program (reader).
> - The longer you run the program, the larger the file size.
> - The message => Master: Child pid is terminating at my time xx.yy because it reached mm.nn in child process will also be recorded in the log file and as well as displaying on the console. There will be a blank line separate the message and the next USER process (for readability).
> - The procedures will only show up in the log file, it will not be display on the console (for readability).
--------------------------------------------------------------------------------
##### CHANGELOG: 
- Date: Thu Oct 3 04:56:29 2019 -0500
    - Edit output log message.
        - Added termination real time message.
        - Added USER (child) PID when displaying the received message.


- Date: Wed Oct 2 10:01:20 2019 -0500
    - Get 100 processes and 2 seconds simulation time termination to work.
    - Making sure real time termination doesn't collide with other termination.
    - Output all the procedure into output (log file) for easier debugging and for grader.
    - Clean up messy code for readability.
		- Rename semaUnlock to semaRelease since lock and unlock can look the same when reading
			the code quickly. This is prevent confusion when reading the code.


- Date: Tue Oct 1 18:31:25 2019 -0500
    - Prototyping 100 processes termination.
	- Fixed the previous ISSUE-1 by initialized srand with USER (child) PID.


- Date: Tue Oct 1 17:17:44 2019 -0500
    - Reidentify critcial section and make sure all semaphore is working.
	- ISSUE-1: USER sometimes may have duplicate time, but have different parent time.
		- Hypothesis:
			1. Parent can only increment clock when no child is reading.
			2. Each process take turn, and no one is favor multiple time until all 
				process get it turn.
			3. Multiple child will have the chance to grab the same time because
				parent have not written a new time (because the way it was implemented).
			4. Because of how the random generator work, it can generate the
				same number multiple time in a row.
			5. Thus, multiple child may have same time, but have different parent time.


- Date: Mon Sep 30 19:41:51 2019 -0500
    - Fixing termination handling PART 7.
            - Reposition semaphore lock and unlock.
            - Working with shmmsg in OSS.
            - Added time reading in USER and write it to shmmsg.


- Date: Mon Sep 30 11:02:56 2019 -0500
    - Fixing termination handling PART 6.
        - Fixed stuck loop when terminating user process.
        - By adding another semaphore.


- Date: Sun Sep 29 17:56:26 2019 -0500
    - Added semaphore lock and unlock function for clockseg and shmmsg.


- Date: Sun Sep 29 17:15:32 2019 -0500
    - Fixing termination handling PART 5.
    - Prototyping accessing shmmsg shared memory.


- Date: Sun Sep 29 05:57:58 2019 -0500
    - Fixing termination handling PART 4.
		- Attempting to add semaphore in USER...


- Date: Sun Sep 29 04:48:48 2019 -0500
    - Fixing termination handling PART 3.
		- USER again was attempting to access shared memory when it already destroy.
			Validation check on accessing shared memory was preventing it from doing
			any further damage.


- Date: Sun Sep 29 04:03:36 2019 -0500
    - Fixing termination handling PART 2.
		- USER again was attempting to access shared memory when it already destroy.
			This causing an issue of deleting shared memory. Shared memory won't delete
			when another process is using it.


- Date: Sat Sep 28 18:09:18 2019 -0500
    - Fixing termination handling PART 1.
		- USER was attempting to access shared memory when it already destroy.


- Date: Sat Sep 28 07:51:13 2019 -0500
    - Prototyping semaphore in oss.c and user.c.


- Date: Fri Sep 27 19:04:03 2019 -0500
    - Edit Makefile.
    - Got shared memory to work.


- Date: Fri Sep 27 07:06:18 2019 -0500
    - Prototyping shared memory in oss.c


- Date: Thu Sep 26 18:26:19 2019 -0500
    - Added Makefile to HW3
    - Added oss.c to HW3
        - Added getopt
        - Added timer function
        - Added parent interrupt function
        - Added parent signal handling
        - Spawn the child processes and have them all immediately terminate correctly
    - Added user.c to HW3
        -  Prototyping...