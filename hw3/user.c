/* ====================================================================================================
# Author: Duc Ngo
# Course: CS4760-001 - Operating System
# File Name: user.c
# Date: 9/26/19
# Last Update: 
# Purpose: 
	This process should start by reading the simulated time system clock generated by oss. It should 
	then generate a random duration number of simulated nanoseconds from 1 to 1000000 and add this to 
	the time it got from reading our shared memory clock. This represents the time in our system when 
	this process should terminate itself.
==================================================================================================== */
#include <stdarg.h>		//va macro
#include <stdio.h>		//printf()
#include <stdlib.h>		//exit()
#include <stdbool.h>	//bool variable
#include <unistd.h>		//standard symbolic constants and types
#include <string.h>		//str function
#include <signal.h>		//signal handling
#include <sys/ipc.h>	//IPC flags
#include <sys/sem.h>	//semget
#include <sys/shm.h>	//shared memory stuff
#include <sys/types.h>	//contains a number of basic derived types
#include <time.h>		//time()


//Constant
#define BUFFER_LENGTH 1024


//Struct
struct clockseg
{
	int second;
	int nanosecond;
};
struct shmmsg
{
	char message[BUFFER_LENGTH];
};


//Static global variable (for dealing with signal handling)
static char *g_executable_name;
static struct clockseg *g_clockseg_shmptr = NULL;
static struct shmmsg *g_shmmsg_shmptr = NULL;
static int g_semid;
static struct sembuf g_sema_operation;


//Function prototype
void strfcat(char *src, char *fmt, ...);
void processInterrupt();
void terminateHandler(int signum);
void releaseClockseg(char *exe_name, int process_id);
void releaseShmmsg(char *exe_name, int process_id);
void semaClocksegLock();
void semaClocksegRelease();
void semaShmmsgLock();
void semaShmmsgRelease();
void semaTermLock();
void semaTermRelease();


/* ====================================================================================================
MAIN
==================================================================================================== */
int main(int argc, char *argv[]) 
{
	//=====Signal Handling======
	processInterrupt();

	//Semaphore terminating process lock
	semaTermLock();

	//--------------------------------------------------
	//=====Initialize resources=====
	g_executable_name = argv[0];
	srand(getpid());

	//--------------------------------------------------
	//Getting the log file
	FILE *fpw = NULL;
	fpw = fopen(argv[1], "a");
	if(fpw == NULL)
	{
		fprintf(stderr, "%s ERROR: unable to write the output file.\n", argv[0]);
		exit(EXIT_FAILURE);
	}
	fclose(fpw);
	fpw = NULL;


	//--------------------------------------------------
	//=====Get semaphore=====
	key_t key3 = ftok("./oss.c", 3);
	if(key3 == (key_t)-1)
	{
		fprintf(stderr, "%s (%d) ERROR: Failed to derive key from ./oss.c for semaphore! Exiting...\n", g_executable_name, getpid());
		exit(EXIT_FAILURE);
	}

	g_semid = semget(key3, 2, 0666);
	if(g_semid == -1)
	{
		exit(EXIT_FAILURE);
	}	


	//--------------------------------------------------
	//=====Getting [clockseg] shared memory=====
	key_t key1 = ftok("./oss.c", 1);
	if(key1 == (key_t)-1)
	{
		fprintf(stderr, "%s (%d) ERROR: Failed to derive key from ./oss.c for [clockseg]! Exiting...\n", g_executable_name, getpid());

		semaTermRelease();
		exit(EXIT_FAILURE);
	}

	//Get [clockseg] shared memory ID
	int clockseg_shmid;
	clockseg_shmid = shmget(key1, sizeof(struct clockseg), 0666);
	if(clockseg_shmid < 0)
	{
		fprintf(stderr, "%s (%d) ERROR: could not get [clockseg] shared memory! Exiting...\n", g_executable_name, getpid());

		semaTermRelease();
		exit(EXIT_FAILURE);
	}

	//Attaching [clockseg] shared memory and check if can attach it.
	g_clockseg_shmptr = shmat(clockseg_shmid, NULL, 0);
	if(g_clockseg_shmptr == (void *)( -1 ))
	{
		fprintf(stderr, "%s (%d) ERROR: fail to attach [clockseg] shared memory! Exiting...\n", g_executable_name, getpid());

		semaTermRelease();
		exit(EXIT_FAILURE);
	}


	//--------------------------------------------------
	//=====Getting [shmmsg] shared memory=====
	key_t key2 = ftok("./oss.c", 2);
	if(key2 == (key_t)-1)
	{
		fprintf(stderr, "%s ERROR: Failed to derive key from ./oss.c for [shmmsg]! Exiting...\n", g_executable_name);

		semaTermRelease();
		exit(EXIT_FAILURE);
	}

	//Get [shmmsg] shared memory ID
	int shmmsg_shmid = shmget(key2, sizeof(struct shmmsg), 0666);
	if(shmmsg_shmid < 0)
	{
		fprintf(stderr, "%s ERROR: could not allocate [shmmsg] shared memory! Exiting...\n", g_executable_name);

		releaseClockseg(g_executable_name, getpid());
		semaTermRelease();
		exit(EXIT_FAILURE);
	}

	//Attaching [shmmsg] shared memory and check if can attach it.
	g_shmmsg_shmptr = shmat(shmmsg_shmid, NULL, 0);
	if(g_shmmsg_shmptr == (void *)( -1 ))
	{
		fprintf(stderr, "%s ERROR: fail to attach [shmmsg] shared memory! Exiting...\n", g_executable_name);

		releaseClockseg(g_executable_name, getpid());
		semaTermRelease();
        exit(EXIT_FAILURE);
	}

	
	//--------------------------------------------------
	/*CRITICAL SECTION: Generate a random duration number of simulated nanoseconds from 
	1 to 1000000 and add this to the time it got from reading our shared memory clock.*/
	semaClocksegLock();
	fpw = fopen(argv[1], "a");
	fprintf(fpw, "%d: In clockseg for random time\n", getpid());
	fflush(fpw);

	int user_nanosecond = rand() % 1000000 + 1;
	user_nanosecond += g_clockseg_shmptr->nanosecond;
	int user_second = 0;
	if(user_nanosecond > 1000000000)
	{
		user_second++;
		user_nanosecond = 1000000000 - user_nanosecond;
	}

	fprintf(fpw, "%d: Exiting clockseg for random time\n", getpid());
	fflush(fpw);
	fclose(fpw);
	fpw = NULL;
	semaClocksegRelease();

	
	//--------------------------------------------------
	/*CRITICAL SECTION: Loop continually, each iteration over the critical section, the user 
	processes should examine the oss-managed clock and see if its maximum duration has passed.*/
	bool checking = true;
	while(checking)
	{
		semaClocksegLock();
		fpw = fopen(argv[1], "a");
		fprintf(fpw, "%d: In clockseg\n", getpid());
		fflush(fpw);

		/*If while in the critical section it sees that its duration is up and there is nothing 
		already in shmMsg, it should send a message to oss that it is going to terminate.
		1. Once it has put a message in shmMsg it should terminate itself, making sure to cede 
		the critical section to any other user processes before doing so.
		2. If shmMsg is not empty the user process should cede the critical section and then when 
		it next enters the critical section it should then try and terminate.*/
		if((strcmp(g_shmmsg_shmptr->message, "") == 0))
		{
			if(g_clockseg_shmptr->second == user_second)
			{		
				if(g_clockseg_shmptr->nanosecond > user_nanosecond)		
				{
					semaShmmsgLock();
					fprintf(fpw, "%d: In shmmsg\n", getpid());
					fflush(fpw);

					char user_message[256];
					strfcat(user_message, "%d.%d (%d)", user_second, user_nanosecond, getpid());
					strncpy(g_shmmsg_shmptr->message, user_message, BUFFER_LENGTH - 1);
					checking = false;

					fprintf(fpw, "%d: Exiting shmmsg\n", getpid());
					fflush(fpw);
					semaShmmsgRelease();
				}
			}
			else if(g_clockseg_shmptr->second > user_second)
			{
				semaShmmsgLock();
				fprintf(fpw, "%d: In shmmsg\n", getpid());
				fflush(fpw);

				char user_message[256];
				strfcat(user_message, "%d.%d (%d)", user_second, user_nanosecond, getpid());
				strncpy(g_shmmsg_shmptr->message, user_message, BUFFER_LENGTH - 1);
				checking = false;

				fprintf(fpw, "%d: Exiting shmmsg\n", getpid());
				fflush(fpw);
				semaShmmsgRelease();
			}
		}

		fprintf(fpw, "%d: Exiting clockseg\n", getpid());
		fflush(fpw);
		fclose(fpw);
		fpw = NULL;
		semaClocksegRelease();
	}


	//--------------------------------------------------
	//=====Clean Up=====
	releaseClockseg(g_executable_name, getpid());
	releaseShmmsg(g_executable_name, getpid());
	semaTermRelease();
    return EXIT_SUCCESS; 
} 


/* ====================================================================================================
STRFCAT
	Similar to strcat, but allow formatting.
==================================================================================================== */
void strfcat(char *src, char *fmt, ...)
{
	char buf[4096];
	va_list args;

	va_start(args, fmt);
	vsprintf(buf, fmt, args);
	va_end(args);

	strcat(src, buf);
}


/* ====================================================================================================
PROCESSINTERRUPT and TERMINATEHANDLER
	Interrupt process when caught SIGTERM. Release semaphore of clockseg, shmmsg, and termination.
	Once that done, simply exit with 2.
==================================================================================================== */
void processInterrupt()
{
	struct sigaction sa;
	sigemptyset(&sa.sa_mask);
	sa.sa_handler = &terminateHandler;
	if(sigaction(SIGTERM, &sa, NULL) == -1)
	{
		perror("ERROR");
	}
}
void terminateHandler(int signum)
{
	semaClocksegRelease();
	semaShmmsgRelease();
	semaTermRelease();
	exit(2);
}


/* ====================================================================================================
releaseClockseg()
	Release [clockseg] shared memory.
==================================================================================================== */
void releaseClockseg(char *exe_name, int process_id)
{
	if(g_clockseg_shmptr != NULL)
	{
		if((shmdt(g_clockseg_shmptr)) < 0)
		{
			fprintf(stderr, "%s (%d) ERROR: could not detach [clockseg] shared memory!\n", exe_name, process_id);
		}
	}
}


/* ====================================================================================================
releaseShmmsg()
	Release [shmmsg] shared memory.
==================================================================================================== */
void releaseShmmsg(char *exe_name, int process_id)
{
	if(g_shmmsg_shmptr != NULL)
	{
		if((shmdt(g_shmmsg_shmptr)) < 0)
		{
			fprintf(stderr, "%s (%d) ERROR: could not detach [clockseg] shared memory!\n", exe_name, process_id);
		}
	}
}


/* ====================================================================================================
semaClocksegLock()
	Invoke semaphore lock of clockseg
==================================================================================================== */
void semaClocksegLock()
{
	//Semaphore #1: clockseg (lock)
	g_sema_operation.sem_num = 0;
	g_sema_operation.sem_op = -1;
	g_sema_operation.sem_flg = 0;
	semop(g_semid, &g_sema_operation, 1);
}	
	

/* ====================================================================================================
semaClocksegRelease()
	Release semaphore lock of clockseg
==================================================================================================== */
void semaClocksegRelease()
{
	//Semaphore #1: clockseg (release)
	g_sema_operation.sem_num = 0;
	g_sema_operation.sem_op = 1;
	g_sema_operation.sem_flg = 0;
	semop(g_semid, &g_sema_operation, 1);
}


/* ====================================================================================================
semaShmmsgLock()
	Invoke semaphore lock of shmmsg
==================================================================================================== */
void semaShmmsgLock()
{
	//Semaphore #2: shmmsg (lock)
	g_sema_operation.sem_num = 1;
	g_sema_operation.sem_op = -1;
	g_sema_operation.sem_flg = 0;
	semop(g_semid, &g_sema_operation, 1);
}


/* ====================================================================================================
semaShmmsgRelease()
	Release semaphore lock of shmmsg
==================================================================================================== */
void semaShmmsgRelease()
{
	//Semaphore #2: shmmsg (release)
	g_sema_operation.sem_num = 1;
	g_sema_operation.sem_op = 1;
	g_sema_operation.sem_flg = 0;
	semop(g_semid, &g_sema_operation, 1);
}


/* ====================================================================================================
semaTermLock()
	Invoke semaphore lock of terminating prcoess
==================================================================================================== */
void semaTermLock()
{
	//Semaphore #3: Terminate USER (lock)
	g_sema_operation.sem_num = 2;
	g_sema_operation.sem_op = -1;
	g_sema_operation.sem_flg = 0;
	semop(g_semid, &g_sema_operation, 1);
}


/* ====================================================================================================
semaTermRelease()
	Release semaphore lock of terminating prcoess
==================================================================================================== */
void semaTermRelease()
{
	//Semaphore #3: Terminate USER (release)
	g_sema_operation.sem_num = 2;
	g_sema_operation.sem_op = 1;
	g_sema_operation.sem_flg = 0;
	semop(g_semid, &g_sema_operation, 1);
}

